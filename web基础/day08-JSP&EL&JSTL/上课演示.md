---
typora-copy-images-to: img
typora-root-url: img
---

# 1.Session综合案例(重要)课下必须完成

## 1.需求

​	验证码是由服务器给浏览器端生成的一张图片，这张图片上有扭曲变形的数字或文字。主要是用来防止恶意注册或者登陆的。

## 2.流程

![image-20201122084821832](/image-20201122084821832.png)



## 3.实现步骤

1.创建登录页面login.html

2.定义一个CheckCodeServlet用来生成验证码图片

3.定义一个LoginServlet用来登录时校验验证码是否正确





## 4.代码实现

### 1.创建登录页面login.html

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录页面</title>
</head>
<body>
<h2>登录页面</h2>
<form action="/loginServlet" method="post">
    账号<input type="text" name="username"><br>
    密码<input type="password" name="password"><br>
    验证码<input type="text" name="code">
    <!--页面一加载就向checkCodeServlet发送请求-->
    <img src="/checkCodeServlet" alt="验证码" style="cursor: pointer" onclick="changeCheckCode(this);"><br>
    <input type="submit" value="登录">
</form>
<script type="text/javascript">
    //定义函数更改验证码图片
    //obj 表示img标签对象
    function changeCheckCode(obj) {//obj=this
        /*
            每次点击验证码图片重新向后台checkCodeServlet发送新的请求
            问题：当我们点击验证码图片，发现浏览器并没有向后台发送请求，因为浏览器认为当前发送的请求的路径是同一个，那么浏览器直接将当前浏览器的图片
            显示了
            解决问题：
            我们可以在请求的路径后面增加一个时间戳，告知浏览器这是一个新的请求，和原来的请求不一样
         */
        // obj.src = "/checkCodeServlet";//同一个请求，不会发送新的请求
        obj.src = "/checkCodeServlet?t="+new Date().getTime();//每次请求都不一样
    }
</script>
</body>
</html>
~~~



### 2.定义一个CheckCodeServlet用来生成验证码图片

~~~java
package com.itheima.sh.a_session_checkcode_01;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

/*
     说明：验证码是一张图片，而这个图片中的内容是使用代码生成的。
        分析和步骤：
        1）创建一个可以存放图片的缓冲区BufferedImage作为画布；
        2）通过画布获取到针对这个画布的画笔；
        3）修改画布的背景颜色为白色；
        4）设置画布的边框，画边框的时候需要注意下，如果这里写画布的宽width和高height ，就会超出画布就会看不见，所以width和height 分别-1；
        5）创建一个获取随机数的对象；
        6）给画布上写数据；
        7）给画布上画干扰线；
        8）需要把画布中的内容响应给浏览器；ImageIO.write(bi,"JPG",response.getOutputStream());
 */
@WebServlet("/checkCodeServlet")
public class CheckCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //定义画布的宽和高
        int width = 120;
        int height = 30;
        //创建一个可以存放图片的缓冲区，作为画布
        //BufferedImage.TYPE_INT_RGB 表示生成图片的类型
        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        //通过画布获取到针对这个画布的画笔
        Graphics g = bi.getGraphics();
        //修改画布的背景颜色  每次使用画笔的时候都得给画笔指定颜色
        g.setColor(Color.WHITE);
        //填充画布
        g.fillRect(0, 0, width, height);
        //设置画布的边框
        //给画笔指定颜色
        g.setColor(Color.RED);
        //给画布画边框 如果这里写width height 就会超过画布，因为边框也会占一个像素，所以这里宽和高都需要-1
        g.drawRect(0, 0, width - 1, height - 1);
        //创建一个获取随机数的对象
        Random r = new Random();
        //给画布上画干扰线
        //循环控制画多条线
        for (int i = 1; i <= 3; i++) {
            //设置画笔的颜色
            g.setColor(new Color(r.nextInt(255), r.nextInt(255), r.nextInt(255)));
            //向画布上画干扰线
            //drawLine(x1, y1, x2, y2) 这里四个参数是因为两个点画成一条线
            g.drawLine(r.nextInt(width), r.nextInt(height), r.nextInt(width), r.nextInt(height));
        }
        //定义数据准备向画布中写数据
        String data = "abcdefghigklmnpqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ123456789";
        //创建字符串缓冲区
        StringBuilder sb = new StringBuilder();

        //循环控制画四个字符
        for (int i = 1; i <= 4; i++) {
            //设置画笔的颜色 Color.BLUE这里的颜色固定了，只能是蓝色，我们可以让颜色随机变化
//			g.setColor(Color.BLUE);
            g.setColor(new Color(r.nextInt(255), r.nextInt(255), r.nextInt(255)));
            //设置字体  Font.ITALIC表示斜体
            g.setFont(new Font("宋体", Font.ITALIC, 20));
            //给画布上写内容 20表示从x轴的位置开始书写 25表示y轴位置开始书写
//			g.drawString("哈哈哈哈", 20, 25);
            /*
             * data.charAt()表示根据函数的参数进行查找字符
             * data.length()表示字符串的长度
             * r.nextInt()表示生成随机数，但是随机数的范围在0~data字符串的长度
             */
            String str = data.charAt(r.nextInt(data.length())) + "";
            g.drawString(str, 20 * i, 25);
            //将验证码内容拼接到字符串缓冲区中
            sb.append(str);
        }
        //  验证码保存到session中
        request.getSession().setAttribute("checkcode", sb.toString());
        //将生成的验证码图片响应给浏览器
        ImageIO.write(bi, "JPG", response.getOutputStream());
    }
}

~~~

### 3.定义一个LoginServlet用来登录时校验验证码是否正确

~~~java
package com.itheima.sh.a_session_checkcode_01;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.处理post请求乱码
        request.setCharacterEncoding("utf-8");
        //2.获取用户名和密码以及输入框的验证码
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        //页面的输入框的验证码
        String input_code = request.getParameter("code");
        //3.从session中获取验证码图片
        // request.getSession().setAttribute("checkcode", sb.toString());
        String session_checkcode = (String) request.getSession().getAttribute("checkcode");
        //4.比较从session中获取的验证码和从页面获取的验证码是否相等：
        if(input_code!=null && input_code.equalsIgnoreCase(session_checkcode)){
            //相等：将用户名和密码传递到dao层向数据库查询
            System.out.println("验证码校验通过");
        }else{
            //不相等：响应给浏览器客户端提示验证码输入有误
            System.out.println("验证码校验没有通过");
        }
    }
}
~~~

小结：

1.验证码校验整体思路：

​	1）页面一加载就向CheckCodeServlet发送请求获取验证码图片上的验证码

​	2）每次点击验证码图片重新向CheckCodeServlet发送请求获取验证码图片上的验证码

​	3）点击登录按钮将输入框输入的验证码和后台存储到session中的验证码进行比较



2.通过验证码案例我们知道session的应用场景，可以在多次请求中共享session中的数据



# 2.servlet的三大域对象(掌握)

| 域对象名                            | 描述                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| session---HttpSession接口           | 比request大，属于一次会话过程中使用的，可以实现多次请求来共享session域对象中的数据。应用场景：验证码  购物车 只有登录才可以操作一些需求等 |
| request---HttpServletRequest接口    | 最小的域对象，只能在一次请求中使用，应用场景：请求转发携带request域对象数据。 |
| servletContext---ServletContext接口 | 最大的域对象，表示当前项目的上下文对象，即当前项目。tomcat服务器一启动就会创建，当tomcat服务器关闭才会销毁。存活时间最长的。多次请求。应用场景：统计网站访问次数，读取当前项目的配置文件等 |

request  < session  < servletContext

【API操作】操作三个作用域对象的API

* 存储数据：setAttribute(name,value);

* 获得数据：getAttribute(name);

* 删除数据：removeAttribute(name)；



# 3. JSP

## 1.介绍(理解)

之前书写的登录案例，如果登录错误我们为了在页面中提示错误信息我们在servlet中编写html标签响应给浏览器，这样会比较麻烦。

我们接下来讲解的jsp就可以解决上述问题，不能在servlet中自己手动编写html标签了，这样使用会很方便。

jsp全称：java server pages java服务器端的页面。jsp属于后台服务器端的技术，本质是一个java类，就是一个servlet，只是在底层使用类似于如下代码编写的：

~~~java
  response.getWriter().print("<html>");
~~~

我们只需要在jsp书写html标签，底层翻译成java代码。

注意：

1.创建jsp的后缀名是.jsp

2.在web项目下的web目录创建

![image-20201122094631935](/image-20201122094631935.png)

3.tomcat执行jsp的时候会将.jsp翻译成.java,然后在编译为.class文件，最后运行.class文件



## 2.jsp入门 掌握

1.在项目的web目录下创建jsp页面

​	![image-20201122095059471](/image-20201122095059471.png)

2.在jsp中书写java代码和html标签

~~~jsp
<%@ page import="java.util.Date" %>
<%@ page import="java.text.SimpleDateFormat" %><%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 9:51
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--书写html标签--%>
    <h1>第一个jsp</h1>
    <%--书写java代码--%>
    <%
        //这里编写java代码
        //需求：获取当前系统时间变为字符串格式
        //1.创建当前系统时间
        Date date = new Date();
        //2.创建日期格式化解析类对象
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        //3.使用日期格式化解析类对象调用格式化方法进行格式化
        String time = sdf.format(date);
        //4.输出格式化的字符串的时间
        System.out.println("time = " + time);
        //响应给页面
        response.getWriter().print(time);
    %>
</body>
</html>

~~~

3.运行访问jsp即可



小结：

1.jsp既可以书写java代码又可以书写html标签页面

2.jsp属于后端的技术，java类实质是一个servlet



## 3.jsp原理(掌握)

1.jsp加载流程图

![image-20201122101124264](/image-20201122101124264.png)

2.查找jsp的源码

![image-20201122101202936](/image-20201122101202936.png)



![image-20201122101301779](/image-20201122101301779.png)

说明：源文件名：jsp文件名_jsp

~~~java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.5.31
 * Generated at: 2020-11-22 01:55:39 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.Date;
import java.text.SimpleDateFormat;
/*
	1.demo01_jsp 表示类名： jsp文件名_jsp变为类名
	2.demo01_jsp类继承了org.apache.jasper.runtime.HttpJspBase类
*/
public final class demo01_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = new java.util.HashSet<>();
    _jspx_imports_classes.add("java.util.Date");
    _jspx_imports_classes.add("java.text.SimpleDateFormat");
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }
  //业务方法，在这里处理业务逻辑
  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
      return;
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      //处理响应的乱码的
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\r');
      out.write('\n');
      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    <h1>第一个jsp</h1>\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
		
        //这里编写java代码
        //需求：获取当前系统时间变为字符串格式
        //1.创建当前系统时间
        Date date = new Date();
        //2.创建日期格式化解析类对象
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        //3.使用日期格式化解析类对象调用格式化方法进行格式化
        String time = sdf.format(date);
        //4.输出格式化的字符串的时间
        System.out.println("time = " + time);
        //响应给页面
        response.getWriter().print(time);
    
      out.write("\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

~~~



说明：

查看jsp是一个servlet：

1）找到jsp源码：

![image-20201122101809552](/image-20201122101809552.png)



2）查找 org.apache.jasper.runtime.HttpJspBase

将tomcat下面的lib包下面的jasper.jar进行解压

![image-20201122101934767](/image-20201122101934767.png)

![image-20201122101959957](/image-20201122101959957.png)

结论：

~~~java
public final class demo01_jsp extends org.apache.jasper.runtime.HttpJspBase{}
public abstract class HttpJspBase extends HttpServlet{}
jsp是一个servlet
~~~



3.总结：

jsp类中具有一个业务方法：

~~~java
 public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {
     /*
     
     	常用的对象：
     	1.request
     	2.response
     	3.session
     	4.application就是ServletContext
     */
 }
~~~



## 4.在jsp页面中书写java代码的三种方式(掌握)

### 1.脚本片段

格式：

~~~java
<%
    //书写java代码
%>
~~~

~~~jsp
<%@ page import="java.util.Date" %>
<%@ page import="java.text.SimpleDateFormat" %><%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 9:51
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--书写html标签--%>
    <h1>第一个jsp</h1>
    <%--书写java代码--%>
    <%
        //这里编写java代码
        //需求：获取当前系统时间变为字符串格式
        //1.创建当前系统时间
        Date date = new Date();
        //2.创建日期格式化解析类对象
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        //3.使用日期格式化解析类对象调用格式化方法进行格式化
        String time = sdf.format(date);
        //4.输出格式化的字符串的时间
        System.out.println("time = " + time);
        //响应给页面
        response.getWriter().print(time);
    %>
</body>
</html>

~~~

说明：

1.使用脚本片段书写的java代码被放到业务方法体中即_jspService中

缺点：书写在脚本片段的java代码不能定义java中的方法吗，只能调用java中的方法

### 2.脚本声明

格式：

~~~jsp
<%!
	//这里书写java代码，在 脚本声明中书写的java代码会放到jsp类的成员位置 
 %>
~~~

~~~jsp
	<%--
        2.脚本声明：java代码放到类的成员位置
    --%>
    <%!
        //定义方法
         public void show(){
            System.out.println("哈哈");
        }

        //定义成员变量
        int num = 10;
    %>
~~~

### 3.脚本表达式

作用：取代之前向页面的输出语句

之前输出页面数据代码：

~~~java
 response.getWriter().print(数据);
~~~

格式：

~~~jsp
<%=输出页面的内容%>
~~~

注意：脚本表达式等号后面的输出内容只能是数据，脚本表达式相当于print方法



~~~jsp
 	<%--
        3.脚本表达式：<%=输出页面的内容%>
    --%>
    <%="锁哥"%>
    <%=123%>
~~~

翻译之后的：

![image-20201122104347114](/image-20201122104347114.png)

小结：

【1】在jsp页面中书写java代码的三种方式

1.脚本片段：

~~~jsp
<%
	java代码，放到service方法体内部
%>
~~~

2.脚本声明

~~~jsp
<%!
 	书写的java代码放到类的成员位置   
 
 %>
~~~

3.脚本表达式：

~~~jsp
<%=输出内容%>
~~~

【2】脚本表达式使用注意事项

 脚本表达式只是用来向页面中输出数据的简化代码：response.getWriter().print(数据);

![image-20201122104855281](/image-20201122104855281.png)

结果：

![image-20201122104907039](/image-20201122104907039.png)

说明：通过查看源码我们发现使用脚本表达式输出的数据代码是放到前面，但是页面结果却最后输出。原因是和两种输出方式的输出流有关：

~~~java
1.脚本表达式使用的输出流是：javax.servlet.jsp.JspWriter out = null;  输出流是JspWriter。JspWriter特点是先将数据放到缓冲区中，然后在一起输出。
   
2.response.getWriter().print("岩岩"); 使用的字符输出流是PrintWriter,PrintWriter字符输出流直接输出到浏览器
~~~





## 5.JSP的三大指令(理解)

### 1.概念

​	JSP指令（directive）是为JSP引擎而设计的，它们并不直接产生任何可见输出效果，而只是告诉引擎如何处理JSP页面中的其余部分。

​	指令用来声明JSP页面的一些属性，比如编码方式，文档类型。我们在servlet中也会声明我们使用的编码方式和响应的文档类型的，而JSP就是用指令来声明的。

### 2.分类

【1】page指令

【2】taglib指令

【3】include指令

指令使用格式：

~~~jsp
<%@ 指令名 属性名="属性值" 属性名="属性值" 属性名="属性值"。。。 %>
~~~

#### 2.1page指令 最重要的

作用：解决响应乱码 当前页面的语言 导包 错误页面等

【1】解决响应乱码,当前页面的语言

~~~jsp

<%@ page contentType="text/html;charset=UTF-8" language="java" %>
1.contentType="text/html;charset=UTF-8 解决响应乱码翻译之后：
 response.setContentType("text/html;charset=UTF-8");
2.当前页面的语言：language="java"  不写默认是java
~~~

**【2】导包快捷键：  alt+enter**

~~~jsp
1.使用哪个包下的就导入哪个包下的类或者接口
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.text.SimpleDateFormat" %>
<%@ page import="java.util.Date" %>
2.一起导入
<%@ page import="java.util.ArrayList,java.text.SimpleDateFormat,java.util.Date" %>
java.util.* 导入java.util包下所有的内容
<%@ page import="java.util.*,java.text.SimpleDateFormat" %>
~~~

【3】 错误页面 了解

~~~jsp
<%--配置错误页面
    如果当前页面报错直接跳转到error.jsp页面
--%>
<%@ page errorPage="/error.jsp" %>
~~~



~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 11:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%--声明当前页面是一个错误页面，其他页面报错了找到这个页面
    	isErrorPage="true" 表示当前页面是一个错误页面，如果值是true表示可以使用对象exception获取错误			信息。默认是false
--%>
<%@page isErrorPage="true" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>异常了</h1>
    <%--获取报错页面的异常信息--%>
    <%
        String message = exception.getMessage();
        response.getWriter().print(message);
    %>
</body>
</html>

~~~



#### 2.2taglib指令

用来导入第三方标签库的，例如下面讲解的JSTL标签库。

~~~jsp
<%@ taglib uri="标签库地址" prefix="标签前缀" 。。。 %>
~~~

举例：

~~~jsp
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
说明：表示引入外部的jstl标签库的。
prefix="c" 表示前缀
uri="http://java.sun.com/jsp/jstl/core" 表示jstl标签库的地址
~~~





#### 2.3include指令

表示在一个jsp页面静态包含某个jsp页面。

格式：

~~~jsp
<%@include file="URL" %> 指定要导入页面的地址
~~~

![image-20201122113433279](/image-20201122113433279.png)

小结：

静态导入jsp的格式：

~~~jsp
<%@ include file="引入的jsp地址"%>
~~~





## 6.开发中配置错误信息页面 掌握

我们在web.xml中进行配置。

【1】配置错误状态码错误信息：

web.xml配置：

~~~xml
 	<!--配置错误页面信息-->
    <error-page>
        <!--表示状态码 404 500 405-->
        <error-code>404</error-code>
        <!--表示报错误跳转的页面-->
        <location>/404.jsp</location>
    </error-page>
~~~

说明：只要访问的资源不存在报404错误就会访问404.jsp页面。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 11:39
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--404图片--%>
    <img src="img/404.jpg">
</body>
</html>

~~~



【2】配置服务中的常见异常信息

~~~xml
 <!--只要web项目报空指针异常就会找null.jsp-->
    <error-page>
       <!--配置常见异常的错误信息-->
        <exception-type>java.lang.NullPointerException</exception-type>
        <!--跳转的页面-->
        <location>/null.jsp</location>
    </error-page>
~~~

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 11:45
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        String s = null;
        s.length();
    %>
</body>
</html>

~~~

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 11:44
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>空指针了。。。</h1>
</body>
</html>

~~~



## 7.JSP常用动作标签 （理解）

常见 我们学习三种：

~~~jsp
1.<jsp:include/>：动态包含
2.<jsp:forward/>：跳转 类似之前学习的转发技术
3.<jsp:param/>：参数设置
~~~

![image-20201122140307547](/image-20201122140307547.png)

### 1.<jsp:include/>：动态包含

格式：

~~~jsp
<jsp:include page="URL"/> URL是被包含的JSP页面
~~~

demo05.jsp

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 14:04
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--
        动态包含demo06.jsp页面
    --%>
    <%
        //定义变量
        int num = 10;
        //使用demo06.jsp中的变量num1
//        System.out.println(num1); 编译报错
    %>
    <%--
        动态包含demo06.jsp页面
    --%>
    <jsp:include page="/demo06.jsp"/>

</body>
</html>

~~~

demo06.jsp

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 14:04
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        //定义变量
        int num = 20;
        int num1 = 30;
        System.out.println(num);
        System.out.println(num1);
    %>
</body>
</html>

~~~

说明：

1.在demo05.jsp页面中动态包含demo06.jsp页面，直接访问demo05.jsp就可以执行dmeo06.jsp页面，同时两个页面中可以定义相同的变量

2.动态包含编译只会生成自己的.java 和.class文件：

![image-20201122141119271](/image-20201122141119271.png)

3.动态包含是将demo06.jsp的结果给demo05.jsp

4.动态包含和静态包含的区别

静态包含使用jsp的指令：

~~~jsp
<%@ include file="包含的jsp页面"%>
~~~

动态包含使用的动作标签：

~~~jsp
<jsp:include page="包含的jsp页面"/>
~~~

![image-20201122141751972](/image-20201122141751972.png)

注意：

​	1）上述使用了静态包含，即在demo05.jsp页面中包含了demo06.jsp页面，我们发现将demo06.jsp所有的代码放到了demo05.jsp页面中。

​	2）静态包含要求两个jsp页面定义的变量不能重名，否则报错

​	3）在demo06.jsp页面中可以使用demo05.jsp页面中定义的变量

![image-20201122142257283](/image-20201122142257283.png)

|                     | 静态包含include指令                                          | 动态包含include动作                                          |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **语法格式**        | <%@include  file="URL"%>                                     | <jsp:include  page="URL"/>                                   |
| **包含的方式**      | 静态包含包含的是页面的内容。如果A包含B，则先将B的页面内容复制到A页面中，再运行A页面。  B页面中不能出现与A页面同名的变量 | 动态包含包含的是页面的执行结果，如果A包含B，则先将B执行，再将B执行的结果包含到A页面中，执行A页面。  B页面中可以出现与A页面中同名的变量 |
| **生成Servlet个数** | 只能生成了一个Servlet                                        | 生成了两个Servlet                                            |



### 2.`<jsp:forward>`和`<jsp:param>`

<jsp:forward>类似于java中的转发技术，可以实现跳转。

<jsp:param>可以用来在跳转过程中携带数据。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 14:27
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--
        1.<jsp:forward>类似于java中的转发技术，可以实现跳转。
                <jsp:forward page="URL"/> 转发
        2.<jsp:param>可以用来在跳转过程中携带数据。
            <jsp:param value="携带的数据" name="根据name的值可以获取value的值"/>
                注意：jsp:param携带的数据拼接到跳转的url后面
    --%>
    <%
        //设置编码表
        request.setCharacterEncoding("utf-8");
        //向request中存储数据
        request.setAttribute("address","北京");
    %>
    <%--
        需求：跳转到demo08.jsp页面并携带数据itcast
    --%>
    <%--<jsp:forward page="/demo08.jsp">
        <jsp:param name="username" value="itcast"/>
    </jsp:forward>--%>
    <%--
        使用动作标签jsp:param携带中文乱码问题：
        _jspx_page_context.forward("/demo08.jsp" + "?" +
        org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode("username",
         request.getCharacterEncoding())+ "=" +
         org.apache.jasper.runtime.JspRuntimeLibrary.
         URLEncode("杨幂", request.getCharacterEncoding()));

        URLEncode("杨幂", request.getCharacterEncoding()) 使用默认的编码表ISO-8859-1对杨幂进行编码

       //设置编码表
        request.setCharacterEncoding("utf-8");

    --%>
    <jsp:forward page="/demo08.jsp">
        <jsp:param name="username" value="杨幂"/>
    </jsp:forward>
</body>
</html>

~~~

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 14:30
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        //1.获取从demo07.jsp页面使用jsp:param动作标签携带的数据
        String username = request.getParameter("username");
        System.out.println("username = " + username);

        //获取request域对象数据
        String address = (String) request.getAttribute("address");
        System.out.println("address = " + address);
    %>
</body>
</html>

~~~

小结：

1.实现跳转类似于转发并在url后面携带数据：

~~~jsp
<jsp:forward page="跳转地址"> 
	 <jsp:param name="username" value="杨幂"/>
</jsp:forward>
~~~

2.在被跳转的页面中使用： String username = request.getParameter("username"); 获取jsp:param 携带的数据

3.request.getAttribute("address");获取的数据一定是 request.setAttribute("address","北京");

4.如果携带中文，需要在当前页面指定编码表然后在转发：

~~~java
 //设置编码表
 request.setCharacterEncoding("utf-8");
~~~



## 8.JSP页面常用对象

【1】JSP页面常用对象

~~~java
1.request
2.response
3.session
4.application（servletContext）
5.final javax.servlet.jsp.PageContext pageContext; 表示当前jsp页面的对象
~~~

【2】jsp中常见的四大域对象

~~~jsp
1.final javax.servlet.jsp.PageContext pageContext; 表示当前jsp页面的对象 一个jsp
2.request 一次请求，可以在多个jsp页面使用
3.session 多次请求
4.application（servletContext） 多个请求
~~~

大小：pageContext < request < session < application

所有的域对象都有三个方法：

~~~java
setAttribute(name,value) 存储值
getAttribute(name)获取值
removeAttribute(name)删除值
~~~



## 9.使用jsp更改之前的登录系统(课下完成)

LoginServlet：

用户名和密码错误跳转到login.jsp页面

![image-20201122151242536](/image-20201122151242536.png)

login.jsp页面：

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 15:06
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>登录页面</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/login.css" rel="stylesheet">
    <script src="js/jquery.js"></script>
    <script src="js/bootstrap.js"></script>
</head>
<body>
<%--
    使用java代码取出request域对象的数据
--%>
<%
    String msg = (String) request.getAttribute("msg");
%>
<div class="container text-center">
    <form class="form-signin" action="/loginServlet" method="get">
        <h2 class="form-signin-heading">登录页面</h2>
        <font color="red"><%=msg%></font>
        <input type="text"  name="username" class="form-control" placeholder="用户名" required autofocus>
        <input type="password"  name="password" class="form-control" placeholder="密码" required>
        <button class="btn btn-lg btn-primary btn-block" type="submit">登录</button>
    </form>
</div>
</body>
</html>

~~~



小结：

使用jsp的好处是：1.页面更加好看  2.不用在servlet使用java代码响应给浏览器html标签了



# 4.EL表达式(掌握)

## 1.EL好处

上述使用jsp改造了登录案例有问题，我们既然发现login.jsp整体页面结构和login.html页面结构是一致的，那么我们是否可以只保留login.jsp呢。

可以实现，好处简化代码开发。

随之带来的问题：

![image-20201122151854414](/image-20201122151854414.png)

如果直接登录login.jsp页面，由于request域对象中还没有数据，那么执行代码：

![image-20201122152056909](/image-20201122152056909.png)

msg是null所以第一次访问就会显示null.

我们这里可以使用EL表达式来解决：

![image-20201122152316667](/image-20201122152316667.png)

EL表达式：${msg},如果msg有数据，则显示，没有内容则不显示。



## 2.EL表达式的介绍

EL全称： Expression Language 中文的意思是EL表达式。

主要作用：从jsp四大域对象(pageContext,request,session,application)中获取数据。

取值格式：

~~~jsp
${四大域对象在el中的名字.域对象中key}
~~~

| 域对象        | 在EL中的对象名称 | 在servlet中的对象名                                          | 说明                                                         |
| ------------- | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| page域        | pageScope        | pageContext，属于javax.servlet.jsp.PageContext类的对象       | page域指的是当前JSP页面，其中存储的数据只在当前页面有效，因为jsp本质是servlet，所以page域只在一个servlet中有效。 |
| request域     | requestScope     | request，属于javax.servlet.http.HttpServletRequest接口的对象 | request域：一次请求或请求链中request域                       |
| session域     | sessionScope     | session,属于javax.servlet.http.HttpSession接口的对象         | session域：一次会话过程中，session域                         |
| application域 | applicationScope | application，属于javax.servlet.ServletContext接口的对象      | application域：服务启动后整个项目对应的ServletContext域      |

EL从四大域对象中获取数据：

| 域对象        | 取值方式                  |
| ------------- | ------------------------- |
| page域        | `${pageScope.key}`        |
| request域     | `${requestScope.key}`     |
| session域     | `${sessionScope.key}`     |
| application域 | `${applicationScope.key}` |

代码演示：

~~~java
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 15:29
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--
        1. 在一个JSP页面中，使用脚本片段分别向page域、request域，session域，application域和中存储数据；
    --%>
    <%
        //1.page域
        pageContext.setAttribute("page","page域的数据");
        //2.request域
        request.setAttribute("request","request域的数据");
        //3.session域
        session.setAttribute("session","session域的数据");
        //4.application域
        application.setAttribute("application","application域的数据");
    %>

    <%--2. 使用EL表达式从这4个域中取值；--%>
    page域:${pageScope.page}<br>
    request域:${requestScope.request}<br>
    session域:${sessionScope.session}<br>
    application域:${applicationScope.application}<br>
</body>
</html>

~~~



## 3.EL表达式搜索数据注意事项

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 15:36
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
        <%
            //2.request域
            request.setAttribute("username","request域的数据");
            //3.session域
            session.setAttribute("username","session域的数据");
        %>
        request域：${requestScope.username}<br>
        session域：${sessionScope.username}<br>
        <%--
            省略对象名：request域的数据
            如果使用EL表达式从jsp四大域对象中获取数据的时候不书写对象名，那么从小向大依次查找，直到找到为止    。
            使用的时候建议加对象名，这样提高搜索效率
        --%>
        省略对象名：${username} 

</body>
</html>

~~~

小结：

在使用EL从jsp四大域对象中获取数据的胡思后不书写对象名，那么从小向大依次查找，直到找到为止    。
 **使用的时候建议加对象名，这样提高搜索效率**



## 4.EL表达式从cookie中取值

回顾：

创建cookie对象：

~~~java
new  Cookie(name,value)
~~~

使用EL表达式在jsp页面中获取cookie中的value：

~~~jsp
${cookie.cookie的name属性值.value}
~~~

实现步骤：

1.创建一个登录的jsp页面

2.创建一个登录的servlet

3.在登录的servlet中获取页面提交的用户名和密码以及复选框按钮

4.如果用户希望记住用户名和密码我们创建cookie，并响应给浏览器

5.在login.jsp页面中使用EL取出cookie中的数据



~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-09-20
  Time: 16:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<form action="/login2Servlet">
    <%--
        5.在login.jsp页面中使用EL取出cookie中的数据
    --%>
    <%--${cookie.cookie的name属性值.value}--%>
    <%--Cookie cookie1 = new Cookie("username", username);--%>
        <%--
            ${cookie.username.value} 使用cookie对象结合EL从浏览器中取出用户名
        --%>
    <input name="username" type="text" placeholder="请输入账号" value="${cookie.username.value}"><br>
    <%--Cookie cookie2 = new Cookie("password", password);--%>
    <input name="password" type="password" placeholder="请输入密码" value="${cookie.password.value}"><br>
    <input type="submit" value="登录">
    <br>
    <input type="checkbox" name="ck" class="checkbox">记住用户名和密码
</form>
</body>
</html>

~~~



~~~java
package com.itheima.sh.b_el_02;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
//2.创建一个登录的servlet

@WebServlet("/login2Servlet")
public class Login2Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //3.在登录的servlet中获取页面提交的用户名和密码以及复选框按钮
        //用户名
        String username = request.getParameter("username");
        //密码
        String password = request.getParameter("password");
        //复选框值
        String ck = request.getParameter("ck");
        //4.如果用户希望记住用户名和密码我们创建cookie，并响应给浏览器
        if("on".equals(ck)){
            Cookie cookie1 = new Cookie("username", username);
            Cookie cookie2 = new Cookie("password", password);
            //设置存活时间
            cookie1.setMaxAge(60*60);
            cookie2.setMaxAge(60*60);
            response.addCookie(cookie1);
            response.addCookie(cookie2);
        }

    }
}

~~~



小结：

使用EL表达式从cookie中获取数据value的值：

~~~jsp
${cookie.cookie的name属性值.value}
~~~



## 5.EL运算符

### 1.算术运算

| 运算符 | 说明 | 使用示例   | 结果 |
| ------ | ---- | ---------- | ---- |
| +      | 加   | `${n1+n2}` | 70   |
| -      | 减   | `${n1-n2}` | 10   |
| *      | 乘   | `${n1*n2}` | 1200 |
| /或div | 除   | `${n1/n4}` | 4    |
| %或mod | 取余 | ${n1%n4}   | 0    |

### 2.关系运算

| 运算符      | 说明                           | 使用示例      | 结果  |
| ----------- | ------------------------------ | ------------- | ----- |
| `== ` 或 eq | 等于  equal                    | `${n1 == n2}` | false |
| `!=` 或ne   | 不等于  not equal              | `${n1 != n2}` | true  |
| `>` 或 gt   | 大于 greater than              | `${n1 > n2}`  | true  |
| `>=` 或ge   | 大于等于 greater than or equal | `${n1 >= n2}` | true  |
| `<` 或 lt   | 小于 less than                 | `${n1 < n2}`  | false |
| `<=`  或le  | 小于等于 less than or equal    | `${n1 <= n2}` | false |



### 3.逻辑运算

| 运算符     | 说明             | 使用示例           | 结果  |
| ---------- | ---------------- | ------------------ | ----- |
| && 或  and | 逻辑与,一假即假  | `${true && false}` | false |
| \|\| 或 or | 逻辑或，一真即真 | `${true || false}` | true  |
| ! 或 not   | 非，取反         | `${!false}`        | true  |



### 4.三元运算

~~~jsp
<%--
 	表达式1?表达式2：表达式3
--%>
三元运算符：<br>
${n1>=n2?"正确":"错误！"}<br>
~~~



### 5. empty运算

表示判断的内容是否为空，以下三种情况被认为是空：

1.空字符串

2.没有数据的集合

3.对象时null

只要满足上述三种情况结果就是true。

使用格式：

~~~jsp
${empty 对象名}
取反：
${not empty 对象名}
~~~

~~~jsp
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 16:11
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%
        request.setAttribute("n1","10");
        request.setAttribute("n2","20");
        request.setAttribute("n3",30);
        request.setAttribute("n4",40);
    %>
    <%--
        1.EL的运算符：和java一致
    --%>
    <%--结果是 10--%>
    n3%n2:${n3 mod n2} <br>

    <%--
        2.EL的关系运算：和java一致
    --%>
    <%--结果是 true--%>
    n4大于等于n1:${n4 ge n1}<br>
    <%--
       3.EL的三元运算：和java一致
   --%>
    <%--判断n1是否大于等于n2--%>
    n1是否大于等于n2：${n1 ge n2 ? "正确" : "错误"}<br>

    <%--
       4.empty运算：

        1.空字符串
        2.没有数据的集合
        3.对象是null
        只要满足上述三种情况结果就是true。
   --%>
    <%
        //创建空字符串
        String s = "";
        //空集合
        ArrayList<String> list = new ArrayList<String>();
        //空对象
        Date date = null;

        //存到域对象中
        request.setAttribute("s",s);
        request.setAttribute("list",list);
        request.setAttribute("date",date);
    %>
    <%--true--%>
    1.空字符串 : ${empty requestScope.s} <br>
    <%--true--%>
    2.没有数据的集合:${empty requestScope.list}<br>
    <%--true--%>
    3.对象时null:${empty requestScope.date}<br>
    <%--false--%>

    取反：${not empty requestScope.date}<br>

</body>
</html>

~~~

 empty运算：

        1.空字符串
        2.没有数据的集合
        3.对象是null
        只要满足上述三种情况结果就是true。




# 5.JSTL标签库(掌握)

## 1.问题

我们之前在jsp页面中即书写了java代码又书写了html标签，这样会造成页面看起来很乱，并且java代码和html标签严重耦合在一起，给维护带来极大的不方便。



## 2.解决问题

我们使用JSTL标签库来取代在jsp页面中书写java代码。就是使用标签代替java代码。



## 3.JSTL标签库的介绍

The JavaServer Pages Standard Tag Library，简称JSTL。JSTL标签库底层使用java代码完成的。属于第三方的：Apache，使用的时候需要导包。

![image-20201122163504920](/image-20201122163504920.png)

## 4.JSTL核心标签库(掌握)

|     标签名称      |                             作用                             |
| :---------------: | :----------------------------------------------------------: |
|   <c:out>(掌握)   |            通常用于输出一段文本内容到客户端浏览器            |
|      <c:set>      |                  用于设置各种Web域中的属性                   |
|    <c:remove>     |                  用于删除各种Web域中的属性                   |
|     <c:catch>     |            用于捕获嵌套在标签体中的内容抛出的异常            |
|   <c:if>(掌握)    |                    java代码if(){}语句功能                    |
| <c:choose>(掌握)  | 用于指定多个条件选择的组合边界，它必须与c:when和c:otherwise标签一起使用 |
| <c:forEach>(掌握) |                   代替java代码for循环语句                    |
|   <c:forTokens>   |                      迭代操作String字符                      |
|     <c:param>     |                      给请求路径添加参数                      |
|      <c:url>      |               重写url，在请求路径添加sessionid               |
|    <c:import>     |         用于在JSP页面中导入一个URL地址指向的资源内容         |
|   <c:redirect>    |          用于将当前的访问请求转发或重定向到其他资源          |

### 4.1<c:out>(掌握)

表示向浏览器中输出数据。

步骤：

1.导入jstl的jar包

![image-20201122164028518](/image-20201122164028518.png)

2.创建jsp页面

3.在jsp页面使用jsp的常见指令taglib导入标签库

<%@ taglib uri="标签库地址" prefix="标签前缀" 。。。 %>

~~~jsp
	1.http://java.sun.com/jsp/jstl/core 表示JSTL的标签库地址
	2.prefix="c" 前缀即c:...
<%@ taglib  uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
~~~



4.使用JSTL标签输出内容

![image-20201122164142768](/image-20201122164142768.png)

~~~jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 16:40
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--使用JSTL标签输出内容--%>
    <c:out value="传智播客"/>
</body>
</html>

~~~





### 4.2<c:if>(掌握)

~~~jsp
<c:if test="判断条件">
	文本
</c:if>标签的作用相当于java中的if判断语句。
1.test属性值中书写的是判断条件，这里书写EL表达式
2.如果判断条件为true则执行文本内容，如果为false则不执行文本内容
~~~

~~~jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 16:47
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--
        使用java代码在jsp页面向request域对象中存储一个对象，使用`<c:if>`标签判断该对象是否为空
    --%>
    <%
        //向request中存储数据
        request.setAttribute("s","abc");
    %>
    <%--
        使用JSTL标签：c:if判断request域对象中的s是否等于null
    --%>
    <c:if test="${s == null}">
        <c:out value="s是null"/>
    </c:if>

    <c:if test="${s != null}">
        <c:out value="s不是null"/>
    </c:if>
</body>
</html>

~~~

小结：

c:if标签使用格式：

~~~jsp
<c:if test="判断条件">
	文本
</c:if>
如果判断条件是true则执行文本，是false则不执行文本
~~~





### 4.3c:foreach标签 掌握

#### 1.介绍

相当于java中的for循环

 c:foreach标签的属性：

![image-20201122165436349](/image-20201122165436349.png)



#### 2.练习

【1】遍历普通数组；

~~~jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%--
  Created by IntelliJ IDEA.
  User: tiansuo
  Date: 2020-11-22
  Time: 16:58
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--
        使用JSTL遍历普通数组；
    --%>
    <%
        //1.定义数组
        int[] arr = {10,20,30};
        //2.使用java的for循环遍历
        //x表示数组中的数据  arr表示数组
        for (int x : arr) {
            response.getWriter().print(x);
        }
        //将arr数组存储到request中
        request.setAttribute("a",arr);
    %>

    <%--使用c:foreach进行遍历--%>
    <%--
        1.items="${requestScope.a}" 表示从request域对象中取出数组名a  request.setAttribute("a",arr);
            items支持EL表达式
        2.var="x" 表示数组中的数据，不支持EL
        3.如果取出var的变量保存的数据必须使用EL表达式 ：${var的属性值}
    --%>
    <c:forEach var="x" items="${requestScope.a}">
        数据:${x}
    </c:forEach>
</body>
</html>

~~~

小结：

1.格式：

~~~jsp
 <c:forEach var="变量保存的数组中的数据" items="${从域对象取出的数组名}">
        数据:${var的属性值}
 </c:forEach>
~~~

2.items="${requestScope.a}" 表示从request域对象中取出数组名a  request.setAttribute("a",arr);
            items支持EL表达式

3.var="x" 表示数组中的数据，不支持EL

**4.如果取出var的变量保存的数据必须使用EL表达式 ：${var的属性值}**











































