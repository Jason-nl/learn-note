## JVM相关面试题汇总

**说一下 JVM 的主要组成部分？及其作用？**

```
类加载器（ClassLoader）
运行时数据区（Runtime Data Area）
执行引擎（Execution Engine）
本地库接口（Native Interface） JNI    native 

组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能

```

**说一下 JVM 运行时数据区？详细介绍下每个区域的作用?**

```
共享:  堆  方法区
私有:  Java虚拟机栈 本地方法栈 程序计数器


程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令；

Java虚拟机栈： 描述方法相关数据

执行方法前创建栈帧
   用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
执行方法时:
   栈帧入栈 
执行完毕方法:
   栈帧出栈 

本地方法栈：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；

Java 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；

    GC垃圾回收: 

-Xms    -Xmx 

方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、运行时常量池等数据。

1.7
 -XX:PermSize    -XX:PermMaxSize 
1.8
 -XX:MetaspaceSize    -XX:MetaspaceMaxSize 


```

**怎么判断对象是否可以被回收？**

```
一般有两种方法来判断：

引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；

** 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。
```

**哪些变量可以作为GC Roots**

```
虚拟机栈中 (栈帧中的本地变量表) 引用的对象 
(正在执行的方法中的变量所引用的对象 可以作为GCroot对象)
方法区中类静态属性引用的对象   static 
方法区中常量的引用对象        final 
```

**Java** **中都有哪些引用类型？**

```

强引用：发生 gc 的时候不会被回收。
Object user = new Object();
软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
new SoftRefrence(user)
弱引用：有用但不是必须的对象，在下一次GC时会被回收。
new WeakRefrence(user)
虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

```

**说一下 JVM 有哪些垃圾回收算法？**

```
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。

分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理或标记清楚算法。

```

**说一下 JVM 有哪些垃圾回收器？**

```
Serial：最早的单线程串行垃圾回收器。
Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。
ParNew：是 Serial 的多线程版本。
Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。
Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。
CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。
G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。


```

**新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？**

```
- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器: G1

新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。
```

**简述分代垃圾回收器是怎么工作的？**

```
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，
From Survivor 变 To Survivor，To Survivor 变 From Survivor。


每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。
分配担保,  存活对象如果幸存者区装不下时  直接进入老年代
大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
```

**Minor GC与Full GC分别在什么时候发生？**

```
新生代内存不够用时候发生Minor GC也叫 Young GC，
老年代内存不够用时候发生Major GC也叫 Full GC 

```

**java中都有哪些类加载器**

```
启动类加载器（Bootstrap ClassLoader）

是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；

扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；

应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

自定义类加载器：通过继承ClassLoader抽象类，实现loadClass方法

```

**哪些情况会触发类加载机制**

```
1.在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发初始化。    
2.对类进行反射调用时，如果类还没有初始化，则需要先触发初始化。
3.初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。
4.虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。

```

**什么是双亲委派模型？**

```
如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

```

**说一下类装载的执行过程？**

```
类装载分为以下 5 个步骤：

加载：根据查找路径找到相应的 class 文件然后导入；
检查：检查加载的 class 文件的正确性；
准备：给类中的静态变量分配内存空间；
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。
初始化：对静态变量和静态代码块执行初始化工作。

```

 **有没有在生产环境下进行过JVM调优，说说过程?**

```
内存溢出
基于 jmap + jprofiler 内存溢出问题排查, 使用 -Xmx -Xms设置调整堆大小


CPU使用率
基于 Jps + jstack + jconsole cpu飙高问题排查, 通过对栈快照定位代码问题
TOP 所有进程内存和CPU的使用情况 已降序排序  
TOP -p java进程ID H   得到线程ID 
jstack 通过上面查询的线程ID定位到出现问题的线程
线程:Runnable  堆栈信息:定位到当前线程执行到哪一步出现了问题
jstack： 也可以排查死锁

基于 JVM 参数调优

```



**常用的 JVM 性能监控的工具？**

```
JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。
jps  jinfo jstat jmap jstack 

jconsole：用于对 JVM 中的内存、线程和类等进行监控；
jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等

idea + jprofiler内存分析

```

**常用的 JVM 调优的参数都有哪些？**

```
-Xms2g：初始化推大小为 2g；
-Xmx2g：堆最大内存为 2g；
-Xmn500M 设置年轻代为500m;
-XX:PermSize=500M ；  1.8之后采用 MetaspaceSize
-XX:MaxPermSize=500M ；  1.8之后采用 MaxMetaspaceSize
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息。
-XX:MaxDirectMemorySize : 设置直接内存的大小
```



##### 生产环境业务代码出现问题

```
4. 通过日志信息，排查是哪个微服务 哪个方法 出现了什么错误

如果不用微服务: 直接登录服务器 找到日志文件 通过tail -f 日志文件
4.1 logback日志框架记录的日志，一般在重要的方法中会通过info级别记录方法入参
                               还会在方法报错,用error级别记录错误的信息
							   4.2 我们采用的是elk的分布式日志方案,   ELK：ElasticSearch LogStash Kibana
     通过logback框架将日志信息输出到LogStash在由LogStash将日志内容输出到ES中
	 通过Kibana可视化的工具来对日志查看
	
	 日志中重点字段:  
	     日志级别:  debug  info warn error
		 微服务名称:    哪个微服务
		 调用类的信息:   哪个类
		 具体日志信息:   记录方法名称  记录方法入参   记录错误描述  异常描述
	 
4.3 微服务中通过redis (list结构) 异步的将产生日志输出到LogStash
4.4 日志那么多，如何在kibana中通过搜索条件搜索日志呢? 
	 在kibana工具的 search框可以通过查询语法查询日志日志字段名称
	 
	日志字段名称 = 值 搜索对应日志 
	 
日志字段名称 = 值 and   or  实现多条件的查询
```

